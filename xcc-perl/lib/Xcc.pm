# This file was automatically generated by SWIG
package Xcc;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package Xccc;
bootstrap Xcc;
package Xcc;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package Xcc;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Xcc;


############# Class : Xcc::Session ##############

package Xcc::Session;
@ISA = qw( Xcc );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xccc::new_Session(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xccc::delete_Session($self);
        delete $OWNER{$self};
    }
}

*server_info = *Xccc::Session_server_info;
*new_adhoc_query = *Xccc::Session_new_adhoc_query;
*new_module_invoke = *Xccc::Session_new_module_invoke;
*new_module_spawn = *Xccc::Session_new_module_spawn;
*new_content = *Xccc::Session_new_content;
*query = *Xccc::Session_query;
*invoke = *Xccc::Session_invoke;
*spawn = *Xccc::Session_spawn;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xcc::Request ##############

package Xcc::Request;
@ISA = qw( Xcc );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xccc::new_Request(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xccc::delete_Request($self);
        delete $OWNER{$self};
    }
}

*submit = *Xccc::Request_submit;
*set_bufsize = *Xccc::Request_set_bufsize;
*set_timeout = *Xccc::Request_set_timeout;
*set_dbname = *Xccc::Request_set_dbname;
*set_dbid = *Xccc::Request_set_dbid;
*set_timestamp = *Xccc::Request_set_timestamp;
*set_name = *Xccc::Request_set_name;
*set_variable = *Xccc::Request_set_variable;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xcc::Result ##############

package Xcc::Result;
@ISA = qw( Xcc );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xccc::new_Result(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xccc::delete_Result($self);
        delete $OWNER{$self};
    }
}

*has_next = *Xccc::Result_has_next;
*next_item = *Xccc::Result_next_item;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xcc::Item ##############

package Xcc::Item;
@ISA = qw( Xcc );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xccc::new_Item(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xccc::delete_Item($self);
        delete $OWNER{$self};
    }
}

*to_string = *Xccc::Item_to_string;
*to_double = *Xccc::Item_to_double;
*to_int = *Xccc::Item_to_int;
*type = *Xccc::Item_type;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Xcc::Content ##############

package Xcc::Content;
@ISA = qw( Xcc );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Xccc::new_Content(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Xccc::delete_Content($self);
        delete $OWNER{$self};
    }
}

*clear_collections = *Xccc::Content_clear_collections;
*clear_permissions = *Xccc::Content_clear_permissions;
*add_collection = *Xccc::Content_add_collection;
*add_permission = *Xccc::Content_add_permission;
*insert = *Xccc::Content_insert;
*set_file_name = *Xccc::Content_set_file_name;
*set_data = *Xccc::Content_set_data;
*set_namespace = *Xccc::Content_set_namespace;
*set_uri = *Xccc::Content_set_uri;
*set_timeout = *Xccc::Content_set_timeout;
*set_format = *Xccc::Content_set_format;
*set_repair = *Xccc::Content_set_repair;
*set_quality = *Xccc::Content_set_quality;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Xcc;

*INTEGER = *Xccc::INTEGER;
*ANYURI = *Xccc::ANYURI;
*BASE64BINARY = *Xccc::BASE64BINARY;
*BINARY = *Xccc::BINARY;
*BOOLEAN = *Xccc::BOOLEAN;
*DATE = *Xccc::DATE;
*DATETIME = *Xccc::DATETIME;
*DAYTIMEDURATION = *Xccc::DAYTIMEDURATION;
*DECIMAL = *Xccc::DECIMAL;
*DOUBLE = *Xccc::DOUBLE;
*DURATION = *Xccc::DURATION;
*FLOAT = *Xccc::FLOAT;
*GDAY = *Xccc::GDAY;
*GMONTH = *Xccc::GMONTH;
*GMONTHDAY = *Xccc::GMONTHDAY;
*GYEAR = *Xccc::GYEAR;
*GYEARMONTH = *Xccc::GYEARMONTH;
*HEXBINARY = *Xccc::HEXBINARY;
*NODE = *Xccc::NODE;
*QNAME = *Xccc::QNAME;
*STRING = *Xccc::STRING;
*TEXT = *Xccc::TEXT;
*TIME = *Xccc::TIME;
*YEARMONTHDURATION = *Xccc::YEARMONTHDURATION;
*UNKNOWN = *Xccc::UNKNOWN;
*FORMAT_NONE = *Xccc::FORMAT_NONE;
*FORMAT_BINARY = *Xccc::FORMAT_BINARY;
*FORMAT_TEXT = *Xccc::FORMAT_TEXT;
*FORMAT_XML = *Xccc::FORMAT_XML;
*CORRECTION_NONE = *Xccc::CORRECTION_NONE;
*CORRECTION_FULL = *Xccc::CORRECTION_FULL;
*INSERT = *Xccc::INSERT;
*UPDATE = *Xccc::UPDATE;
*READ = *Xccc::READ;
*EXECUTE = *Xccc::EXECUTE;
1;
